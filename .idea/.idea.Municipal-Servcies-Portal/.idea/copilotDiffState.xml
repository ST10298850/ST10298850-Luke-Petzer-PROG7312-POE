<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Municipal-Servcies-Portal/appsettings.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Municipal-Servcies-Portal/appsettings.json" />
              <option name="originalContent" value="{&#10;  &quot;ConnectionStrings&quot;: {&#10;    &quot;MunicipalDB&quot;: &quot;Server=localhost,1433;Database=MunicipalServices;User Id=sa;Password=YourStrong!Passw0rd;TrustServerCertificate=True;&quot;&#10;  },&#10;  &quot;Logging&quot;: {&#10;    &quot;LogLevel&quot;: {&#10;      &quot;Default&quot;: &quot;Information&quot;,&#10;      &quot;Microsoft.AspNetCore&quot;: &quot;Warning&quot;&#10;    }&#10;  },&#10;  &quot;AllowedHosts&quot;: &quot;*&quot;&#10;}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;ConnectionStrings&quot;: {&#10;    &quot;MunicipalDB&quot;: &quot;Server=localhost,1433;Database=MunicipalServices;User Id=sa;Password=YourStrong!Passw0rd;TrustServerCertificate=True;&quot;&#10;  },&#10;  &quot;Logging&quot;: {&#10;    &quot;LogLevel&quot;: {&#10;      &quot;Default&quot;: &quot;Information&quot;,&#10;      &quot;Microsoft.AspNetCore&quot;: &quot;Warning&quot;&#10;    }&#10;  },&#10;  &quot;AllowedHosts&quot;: &quot;*&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SEARCH_IMPLEMENTATION.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SEARCH_IMPLEMENTATION.md" />
              <option name="originalContent" value="# Search Functionality Implementation Summary&#10;&#10;## ✅ What Was Implemented&#10;&#10;### 1. **Service Layer (LocalEventsService.cs)**&#10;- ✅ **SearchEventsAsync method** - Filters events by name, category, and date&#10;  - Uses `AsQueryable()` to build efficient database queries&#10;  - Applies filters conditionally (only when parameters are provided)&#10;  - Case-insensitive search using `StringComparison.OrdinalIgnoreCase`&#10;  - Returns filtered results asynchronously&#10;&#10;**Key Features:**&#10;- Partial match for event name (e.g., &quot;Clean&quot; matches &quot;Community Clean-Up Day&quot;)&#10;- Exact match for category&#10;- Date range filtering (start date and end date support)&#10;&#10;### 2. **Controller Layer (LocalEventsController.cs)**&#10;- ✅ **Updated Index action** to accept search parameters:&#10;  - `searchName` - Event name/keyword&#10;  - `category` - Category filter&#10;  - `date` - Date filter&#10;&#10;**Logic Flow:**&#10;1. Check if any search parameters are provided&#10;2. If yes → call `SearchEventsAsync()` with filters&#10;3. If no → call `GetUpcomingEventsAsync()` to show all events&#10;4. Record the search for future recommendation tracking&#10;5. Build ViewModel and return to view&#10;&#10;### 3. **View Layer (Index.cshtml)**&#10;- ✅ **Form submission** using GET method&#10;  - Form parameters match controller action parameters exactly&#10;  - Preserves search values after form submission using `Context.Request.Query[]`&#10;  - Category dropdown maintains selected value after search&#10;  - Date input retains selected date&#10;&#10;**Form Fields:**&#10;- `searchName` - Text input for event name/keyword&#10;- `category` - Dropdown populated from database categories&#10;- `date` - Date picker for filtering by date&#10;&#10;**Buttons:**&#10;- &quot;Search Events&quot; - Submits the form with all filters&#10;- &quot;Clear Filters&quot; - Reloads page without any query parameters&#10;&#10;### 4. **Enhanced UX (localevents.js) - OPTIONAL**&#10;- ✅ **Debounce functionality** - Delays search until user stops typing (500ms)&#10;- ✅ **Instant search** on category/date change&#10;- ✅ **Two implementation options:**&#10;  - Option 1: Simple URL reload (currently active)&#10;  - Option 2: AJAX fetch (commented out, ready to use)&#10;&#10;##  How It Works&#10;&#10;### Step-by-Step Flow:&#10;&#10;1. **User enters search criteria** in the filter form&#10;2. **Form submits to `/LocalEvents/Index`** with query parameters&#10;   - Example: `/LocalEvents/Index?searchName=clean&amp;category=Community&amp;date=2024-10-20`&#10;3. **Controller receives parameters** and checks if any are provided&#10;4. **Service layer queries database** with applied filters&#10;5. **Results are returned** to the controller&#10;6. **ViewModel is built** with filtered events, announcements, and categories&#10;7. **View displays results** with search criteria preserved in form fields&#10;&#10;### Example Searches:&#10;&#10;```&#10;- Search by name only: ?searchName=festival&#10;- Search by category: ?category=Community Events&#10;- Search by date: ?date=2024-10-20&#10;- Combined search: ?searchName=clean&amp;category=Community&amp;date=2024-10-20&#10;```&#10;&#10;##  Code Comments Explained&#10;&#10;All code includes detailed comments explaining:&#10;- **What each section does**&#10;- **Why it's implemented that way**&#10;- **How the data flows**&#10;- **What each parameter means**&#10;&#10;### Key Comments Added:&#10;&#10;**Service Layer:**&#10;- How `AsQueryable()` works&#10;- Why we use `StringComparison.OrdinalIgnoreCase`&#10;- How `Contains()` vs `Equals()` differ&#10;- When the database query actually executes&#10;&#10;**Controller:**&#10;- How parameter binding works from query string&#10;- Why we check for null/empty values&#10;- How the search is recorded for recommendations&#10;- What happens when no filters are provided&#10;&#10;**View:**&#10;- How form submission works with GET method&#10;- How to preserve form values after submission&#10;- Why we use `asp-controller` and `asp-action`&#10;- How the &quot;Clear Filters&quot; button works&#10;&#10;**JavaScript:**&#10;- How debounce prevents excessive API calls&#10;- Why we use 500ms delay&#10;- Difference between instant search and debounced search&#10;- Two implementation options (reload vs AJAX)&#10;&#10;## ✅ Testing Checklist&#10;&#10;- [ ] Navigate to `/LocalEvents/Index`&#10;- [ ] Enter a search term and click &quot;Search Events&quot;&#10;- [ ] Verify results are filtered correctly&#10;- [ ] Verify search term remains in the input field after search&#10;- [ ] Select a category and search&#10;- [ ] Verify category remains selected after search&#10;- [ ] Select a date and search&#10;- [ ] Verify date remains selected after search&#10;- [ ] Click &quot;Clear Filters&quot; - verify all filters are cleared&#10;- [ ] Test combined filters (name + category + date)&#10;&#10;##  What's Still Needed for Full Marks&#10;&#10;This implementation covers the **Search Functionality** requirement. You still need:&#10;&#10;1. ❌ **Stack/Queue for search history** (15 marks)&#10;2. ❌ **Personalized recommendations** based on search patterns (30 marks)&#10;&#10;The current implementation includes:&#10;- ✅ Search by name, category, and date&#10;- ✅ All required data structures (Dictionary, SortedDictionary, HashSet, PriorityQueue)&#10;- ✅ User-friendly presentation&#10;- ✅ Form state preservation&#10;- ⚠️ Search recording (stub only - needs full implementation for recommendations)&#10;&#10;##  Next Steps&#10;&#10;To complete the assignment:&#10;1. Implement search history using Queue/Stack&#10;2. Build recommendation algorithm based on user search patterns&#10;3. Display personalized recommendations (not just first 3 events)&#10;" />
              <option name="updatedContent" value="# Search Functionality Implementation Summary&#10;&#10;## ✅ What Was Implemented&#10;&#10;### 1. **Service Layer (LocalEventsService.cs)**&#10;- ✅ **SearchEventsAsync method** - Filters events by name, category, and date&#10;  - Uses `AsQueryable()` to build efficient database queries&#10;  - Applies filters conditionally (only when parameters are provided)&#10;  - Case-insensitive search using `StringComparison.OrdinalIgnoreCase`&#10;  - Returns filtered results asynchronously&#10;&#10;**Key Features:**&#10;- Partial match for event name (e.g., &quot;Clean&quot; matches &quot;Community Clean-Up Day&quot;)&#10;- Exact match for category&#10;- Date range filtering (start date and end date support)&#10;&#10;### 2. **Controller Layer (LocalEventsController.cs)**&#10;- ✅ **Updated Index action** to accept search parameters:&#10;  - `searchName` - Event name/keyword&#10;  - `category` - Category filter&#10;  - `date` - Date filter&#10;&#10;**Logic Flow:**&#10;1. Check if any search parameters are provided&#10;2. If yes → call `SearchEventsAsync()` with filters&#10;3. If no → call `GetUpcomingEventsAsync()` to show all events&#10;4. Record the search for future recommendation tracking&#10;5. Build ViewModel and return to view&#10;&#10;### 3. **View Layer (Index.cshtml)**&#10;- ✅ **Form submission** using GET method&#10;  - Form parameters match controller action parameters exactly&#10;  - Preserves search values after form submission using `Context.Request.Query[]`&#10;  - Category dropdown maintains selected value after search&#10;  - Date input retains selected date&#10;&#10;**Form Fields:**&#10;- `searchName` - Text input for event name/keyword&#10;- `category` - Dropdown populated from database categories&#10;- `date` - Date picker for filtering by date&#10;&#10;**Buttons:**&#10;- &quot;Search Events&quot; - Submits the form with all filters&#10;- &quot;Clear Filters&quot; - Reloads page without any query parameters&#10;&#10;### 4. **Enhanced UX (localevents.js) - OPTIONAL**&#10;- ✅ **Debounce functionality** - Delays search until user stops typing (500ms)&#10;- ✅ **Instant search** on category/date change&#10;- ✅ **Two implementation options:**&#10;  - Option 1: Simple URL reload (currently active)&#10;  - Option 2: AJAX fetch (commented out, ready to use)&#10;&#10;##  How It Works&#10;&#10;### Step-by-Step Flow:&#10;&#10;1. **User enters search criteria** in the filter form&#10;2. **Form submits to `/LocalEvents/Index`** with query parameters&#10;   - Example: `/LocalEvents/Index?searchName=clean&amp;category=Community&amp;date=2024-10-20`&#10;3. **Controller receives parameters** and checks if any are provided&#10;4. **Service layer queries database** with applied filters&#10;5. **Results are returned** to the controller&#10;6. **ViewModel is built** with filtered events, announcements, and categories&#10;7. **View displays results** with search criteria preserved in form fields&#10;&#10;### Example Searches:&#10;&#10;```&#10;- Search by name only: ?searchName=festival&#10;- Search by category: ?category=Community Events&#10;- Search by date: ?date=2024-10-20&#10;- Combined search: ?searchName=clean&amp;category=Community&amp;date=2024-10-20&#10;```&#10;&#10;##  Code Comments Explained&#10;&#10;All code includes detailed comments explaining:&#10;- **What each section does**&#10;- **Why it's implemented that way**&#10;- **How the data flows**&#10;- **What each parameter means**&#10;&#10;### Key Comments Added:&#10;&#10;**Service Layer:**&#10;- How `AsQueryable()` works&#10;- Why we use `StringComparison.OrdinalIgnoreCase`&#10;- How `Contains()` vs `Equals()` differ&#10;- When the database query actually executes&#10;&#10;**Controller:**&#10;- How parameter binding works from query string&#10;- Why we check for null/empty values&#10;- How the search is recorded for recommendations&#10;- What happens when no filters are provided&#10;&#10;**View:**&#10;- How form submission works with GET method&#10;- How to preserve form values after submission&#10;- Why we use `asp-controller` and `asp-action`&#10;- How the &quot;Clear Filters&quot; button works&#10;&#10;**JavaScript:**&#10;- How debounce prevents excessive API calls&#10;- Why we use 500ms delay&#10;- Difference between instant search and debounced search&#10;- Two implementation options (reload vs AJAX)&#10;&#10;## ✅ Testing Checklist&#10;&#10;- [ ] Navigate to `/LocalEvents/Index`&#10;- [ ] Enter a search term and click &quot;Search Events&quot;&#10;- [ ] Verify results are filtered correctly&#10;- [ ] Verify search term remains in the input field after search&#10;- [ ] Select a category and search&#10;- [ ] Verify category remains selected after search&#10;- [ ] Select a date and search&#10;- [ ] Verify date remains selected after search&#10;- [ ] Click &quot;Clear Filters&quot; - verify all filters are cleared&#10;- [ ] Test combined filters (name + category + date)&#10;&#10;##  What's Still Needed for Full Marks&#10;&#10;This implementation covers the **Search Functionality** requirement. You still need:&#10;&#10;1. ❌ **Stack/Queue for search history** (15 marks)&#10;2. ❌ **Personalized recommendations** based on search patterns (30 marks)&#10;&#10;The current implementation includes:&#10;- ✅ Search by name, category, and date&#10;- ✅ All required data structures (Dictionary, SortedDictionary, HashSet, PriorityQueue)&#10;- ✅ User-friendly presentation&#10;- ✅ Form state preservation&#10;- ⚠️ Search recording (stub only - needs full implementation for recommendations)&#10;&#10;##  Next Steps&#10;&#10;To complete the assignment:&#10;1. Implement search history using Queue/Stack&#10;2. Build recommendation algorithm based on user search patterns&#10;3. Display personalized recommendations (not just first 3 events)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/VIDEO_EXPLANATIONS.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/VIDEO_EXPLANATIONS.md" />
              <option name="updatedContent" value="# Video Explanation Guide - Municipal Services Portal&#10;&#10;This document contains detailed explanations for key code sections to use in your video presentation.&#10;&#10;---&#10;&#10;##  Prompt 1 — Search/Filter Logic&#10;&#10;### SearchEventsAsync() Method Explanation&#10;&#10;**Location:** `LocalEventsService.cs` (Lines 146-183)&#10;&#10;#### What It Does:&#10;The `SearchEventsAsync()` method provides flexible, multi-criteria filtering for events using Entity Framework Core's powerful query capabilities.&#10;&#10;#### How It Works:&#10;&#10;**1. Start with a Queryable Collection:**&#10;```csharp&#10;var query = _context.Events.AsQueryable();&#10;```&#10;- Creates an IQueryable that allows us to build the SQL query dynamically&#10;- No database call happens yet - this is query composition&#10;&#10;**2. Apply Keyword Filter (Partial Match):**&#10;```csharp&#10;if (!string.IsNullOrEmpty(name))&#10;{&#10;    query = query.Where(e =&gt; e.Title.ToLower().Contains(name.ToLower()));&#10;}&#10;```&#10;- **Case-insensitive** partial match using `.ToLower()`&#10;- Searches in event titles (e.g., &quot;yoga&quot; matches &quot;Yoga in the Park&quot;)&#10;- Only applied if user provides search text&#10;&#10;**3. Apply Category Filter (Exact Match):**&#10;```csharp&#10;if (!string.IsNullOrEmpty(category))&#10;{&#10;    query = query.Where(e =&gt; e.Category.ToLower() == category.ToLower());&#10;}&#10;```&#10;- Exact match on category (e.g., &quot;Community Events&quot;)&#10;- Case-insensitive comparison&#10;- Only applied if user selects a category&#10;&#10;**4. Apply Date Range Filter:**&#10;```csharp&#10;if (startDate.HasValue)&#10;{&#10;    var dateOnly = startDate.Value.Date;&#10;    query = query.Where(e =&gt; e.StartDate.Date &gt;= dateOnly);&#10;}&#10;```&#10;- Filters events FROM the selected date onwards&#10;- Uses `.Date` to ignore time component&#10;- Open-ended range (shows all future events from that date)&#10;&#10;**5. Filter Active Events Only:**&#10;```csharp&#10;query = query.Where(e =&gt; e.IsActive);&#10;```&#10;- Ensures only active events are shown (soft delete pattern)&#10;&#10;**6. Execute Query Asynchronously:**&#10;```csharp&#10;return await query.OrderBy(e =&gt; e.StartDate).ToListAsync();&#10;```&#10;- **ToListAsync()** sends the query to SQL Server asynchronously&#10;- Orders results by start date chronologically&#10;- Non-blocking operation - UI remains responsive&#10;&#10;#### EF Core Magic:&#10;- All the `Where()` clauses are combined into a **single SQL query**&#10;- EF Core translates LINQ to SQL efficiently&#10;- Only the matching rows are returned from the database&#10;- Example SQL generated:&#10;  ```sql&#10;  SELECT * FROM Events &#10;  WHERE IsActive = 1 &#10;    AND LOWER(Title) LIKE '%yoga%'&#10;    AND LOWER(Category) = 'health &amp; wellness'&#10;    AND CAST(StartDate AS DATE) &gt;= '2025-10-20'&#10;  ORDER BY StartDate&#10;  ```&#10;&#10;#### Key Benefits:&#10;✅ **Flexible** - Any combination of filters works  &#10;✅ **Efficient** - Single database query, not multiple  &#10;✅ **Asynchronous** - Non-blocking UI  &#10;✅ **Type-safe** - Compile-time checking  &#10;&#10;---&#10;&#10;##  Prompt 2 — Recommendations&#10;&#10;### How GetRecommendedEventsAsync() and RecordSearchAsync() Work Together&#10;&#10;**Location:** `LocalEventsService.cs` (Lines 186-267)&#10;&#10;#### The Big Picture:&#10;These two methods form a **personalized recommendation engine** that learns from user behavior to suggest relevant events.&#10;&#10;---&#10;&#10;### Part 1: RecordSearchAsync() - Tracking User Behavior&#10;&#10;**Location:** Lines 186-191&#10;&#10;```csharp&#10;public Task RecordSearchAsync(string? searchName, string? category, DateTime? date, DateTime? endDate)&#10;{&#10;    _searchHistoryService.AddSearch(searchName, category, date);&#10;    return Task.CompletedTask;&#10;}&#10;```&#10;&#10;#### What It Does:&#10;- Called every time a user performs a search&#10;- Captures three pieces of data:&#10;  - **searchName**: Keywords typed (e.g., &quot;farmers market&quot;)&#10;  - **category**: Selected category (e.g., &quot;Community Events&quot;)&#10;  - **date**: Selected date filter&#10;&#10;#### Where It's Called:&#10;In `LocalEventsController.cs`:&#10;```csharp&#10;await _localEventsService.RecordSearchAsync(searchName, category, date, null);&#10;```&#10;&#10;#### Storage Mechanism:&#10;- Stored in **session storage** (not database)&#10;- Maximum 10 recent searches tracked&#10;- Persists for 2 hours&#10;- Privacy-friendly - data stays in user's session&#10;&#10;---&#10;&#10;### Part 2: GetRecommendedEventsAsync() - Generating Recommendations&#10;&#10;**Location:** Lines 193-267&#10;&#10;#### Step-by-Step Breakdown:&#10;&#10;**Step 1: Load Data Structures**&#10;```csharp&#10;await LoadEventsIntoStructuresAsync();&#10;var searchHistory = _searchHistoryService.GetSearchHistory();&#10;```&#10;- Loads all events into memory-based data structures for fast access&#10;- Retrieves user's search history from session&#10;&#10;**Step 2: Fallback for New Users**&#10;```csharp&#10;if (searchHistory.Count == 0)&#10;{&#10;    return _upcomingEventsQueue.UnorderedItems&#10;        .Select(x =&gt; x.Element)&#10;        .OrderBy(e =&gt; e.StartDate)&#10;        .Take(5)&#10;        .ToList();&#10;}&#10;```&#10;- If no search history exists, show next 5 upcoming events&#10;- Good for first-time visitors&#10;&#10;**Step 3: Analyze Search Patterns**&#10;```csharp&#10;var categoryCounts = new Dictionary&lt;string, int&gt;();&#10;var searchTerms = new List&lt;string&gt;();&#10;&#10;foreach (var item in searchHistory)&#10;{&#10;    // Track category frequency&#10;    if (!string.IsNullOrEmpty(item.Category))&#10;    {&#10;        if (!categoryCounts.ContainsKey(item.Category)) &#10;            categoryCounts[item.Category] = 0;&#10;        categoryCounts[item.Category]++;&#10;    }&#10;    &#10;    // Collect search keywords&#10;    if (!string.IsNullOrEmpty(item.SearchText))&#10;    {&#10;        searchTerms.Add(item.SearchText.ToLower());&#10;    }&#10;}&#10;```&#10;- **Frequency analysis**: Counts how many times each category was searched&#10;- **Keyword collection**: Gathers all search terms used&#10;- Example: If user searched &quot;Parks &amp; Recreation&quot; 3 times and &quot;Community Events&quot; 1 time, Parks &amp; Recreation gets priority&#10;&#10;**Step 4: Find Most Popular Category**&#10;```csharp&#10;var topCategory = categoryCounts.OrderByDescending(x =&gt; x.Value).FirstOrDefault().Key;&#10;```&#10;- Identifies the category the user searches most frequently&#10;- This becomes the primary recommendation driver&#10;&#10;**Step 5: Strategy 1 - Category-Based Recommendations**&#10;```csharp&#10;if (!string.IsNullOrEmpty(topCategory) &amp;&amp; _eventsByCategory.ContainsKey(topCategory))&#10;{&#10;    recommended.AddRange(_eventsByCategory[topCategory]&#10;        .Where(e =&gt; e.StartDate &gt;= DateTime.Now)&#10;        .OrderBy(e =&gt; e.StartDate)&#10;        .Take(5));&#10;}&#10;```&#10;- Uses the **Dictionary** data structure for O(1) lookup&#10;- Gets events from the most-searched category&#10;- Only future events&#10;- Takes up to 5 events&#10;&#10;**Step 6: Strategy 2 - Keyword-Based Recommendations**&#10;```csharp&#10;if (recommended.Count &lt; 5 &amp;&amp; searchTerms.Any())&#10;{&#10;    var existingIds = recommended.Select(e =&gt; e.Id).ToHashSet();&#10;    var keywordMatches = await _context.Events&#10;        .Where(e =&gt; e.IsActive &amp;&amp; e.StartDate &gt;= DateTime.Now &amp;&amp; !existingIds.Contains(e.Id))&#10;        .ToListAsync();&#10;    &#10;    var matchingEvents = keywordMatches&#10;        .Where(e =&gt; searchTerms.Any(term =&gt; &#10;            e.Title.ToLower().Contains(term) || &#10;            e.Description.ToLower().Contains(term) ||&#10;            e.Category.ToLower().Contains(term)))&#10;        .OrderBy(e =&gt; e.StartDate)&#10;        .Take(5 - recommended.Count);&#10;    &#10;    recommended.AddRange(matchingEvents);&#10;}&#10;```&#10;- Kicks in if we don't have 5 recommendations yet&#10;- Searches for events matching user's **keywords** in:&#10;  - Event title&#10;  - Event description&#10;  - Event category&#10;- Avoids duplicates using `existingIds` HashSet&#10;- Example: User searched &quot;yoga&quot; → recommends &quot;Yoga in the Park&quot;&#10;&#10;**Step 7: Strategy 3 - General Fallback**&#10;```csharp&#10;if (recommended.Count &lt; 5)&#10;{&#10;    var existingIds = recommended.Select(e =&gt; e.Id).ToHashSet();&#10;    var fallback = _upcomingEventsQueue.UnorderedItems&#10;        .Select(x =&gt; x.Element)&#10;        .Where(e =&gt; !existingIds.Contains(e.Id))&#10;        .OrderBy(e =&gt; e.StartDate)&#10;        .Take(5 - recommended.Count)&#10;        .ToList();&#10;    recommended.AddRange(fallback);&#10;}&#10;```&#10;- Final safety net: fills remaining slots with general upcoming events&#10;- Ensures we always show 5 recommendations&#10;&#10;**Step 8: Return Results**&#10;```csharp&#10;return recommended.Distinct().Take(5).ToList();&#10;```&#10;- Removes any duplicate events&#10;- Guarantees exactly 5 or fewer recommendations&#10;&#10;---&#10;&#10;### Real-World Example:&#10;&#10;**User Behavior:**&#10;1. Searches &quot;yoga&quot; → No category&#10;2. Searches for &quot;Parks &amp; Recreation&quot; category&#10;3. Searches for &quot;Parks &amp; Recreation&quot; category again&#10;4. Searches &quot;hiking&quot; → No category&#10;&#10;**Analysis:**&#10;- `categoryCounts`: { &quot;Parks &amp; Recreation&quot;: 2 }&#10;- `searchTerms`: [&quot;yoga&quot;, &quot;hiking&quot;]&#10;- `topCategory`: &quot;Parks &amp; Recreation&quot;&#10;&#10;**Recommendations Generated:**&#10;1. **Strategy 1**: Parks &amp; Recreation Cleanup Day (top category match)&#10;2. **Strategy 1**: Hiking Trail Grand Opening (top category match)&#10;3. **Strategy 2**: Yoga in the Park (keyword &quot;yoga&quot; match)&#10;4. **Strategy 3**: Community Town Hall (general fallback)&#10;5. **Strategy 3**: Summer Festival (general fallback)&#10;&#10;---&#10;&#10;### Key Benefits:&#10;✅ **Multi-strategy** - Combines category, keyword, and fallback approaches  &#10;✅ **Personalized** - Based on actual user behavior  &#10;✅ **Privacy-conscious** - Session-based, not tracked in database  &#10;✅ **Progressive** - Gets better as user searches more  &#10;✅ **Fail-safe** - Always shows relevant content even for new users  &#10;&#10;---&#10;&#10;##  Prompt 3 — View Binding&#10;&#10;### LocalEvents/Index.cshtml Layout Explanation&#10;&#10;**Location:** `Views/LocalEvents/Index.cshtml`&#10;&#10;#### Model Binding:&#10;```csharp&#10;@model Municipal_Servcies_Portal.ViewModels.LocalEventsViewModel&#10;```&#10;- The view receives a **LocalEventsViewModel** object&#10;- Contains three main collections:&#10;  - `Model.RecommendedEvents` (IEnumerable&lt;Event&gt;)&#10;  - `Model.Events` (IEnumerable&lt;Event&gt;)&#10;  - `Model.Announcements` (IEnumerable&lt;Announcement&gt;)&#10;  - `Model.Categories` (IEnumerable&lt;string&gt;)&#10;&#10;---&#10;&#10;### Section 1: Recommendations Section&#10;&#10;**Lines 56-80** (approximately)&#10;&#10;```csharp&#10;@if (Model.RecommendedEvents != null &amp;&amp; Model.RecommendedEvents.Any())&#10;{&#10;    &lt;section class=&quot;recommendations-section&quot;&gt;&#10;        &lt;h2 class=&quot;section-title&quot;&gt;Recommended for You&lt;/h2&gt;&#10;        &lt;p class=&quot;recommendations-subtitle&quot;&gt;Based on your interests and search history&lt;/p&gt;&#10;&#10;        &lt;div class=&quot;recommendations-grid&quot;&gt;&#10;            @foreach (var evt in Model.RecommendedEvents.Take(3))&#10;            {&#10;                // Display recommendation cards&#10;            }&#10;        &lt;/div&gt;&#10;    &lt;/section&gt;&#10;}&#10;```&#10;&#10;#### How It Works:&#10;1. **Null check**: `Model.RecommendedEvents != null &amp;&amp; Model.RecommendedEvents.Any()`&#10;   - Only shows section if recommendations exist&#10;   - Prevents errors for new users&#10;&#10;2. **Three-column grid**: `recommendations-grid` CSS class&#10;   - Displays horizontally on desktop&#10;   - Stacks vertically on mobile&#10;&#10;3. **Top 3 recommendations**: `.Take(3)`&#10;   - Shows only the top 3 recommendations&#10;   - Service provides up to 5, view displays 3&#10;&#10;4. **Dynamic category colors**:&#10;```csharp&#10;var categoryColor = evt.Category.Contains(&quot;Community&quot;) ? &quot;blue&quot; : &#10;                  evt.Category.Contains(&quot;Utilities&quot;) || evt.Category.Contains(&quot;Parks&quot;) ? &quot;green&quot; : &#10;                  evt.Category.Contains(&quot;Cultural&quot;) || evt.Category.Contains(&quot;Culture&quot;) ? &quot;orange&quot; : &quot;blue&quot;;&#10;```&#10;   - Color-codes badges based on category&#10;   - Visual differentiation&#10;&#10;5. **Bootstrap Icons**:&#10;```html&#10;&lt;i class=&quot;bi bi-calendar-event event-icon&quot;&gt;&lt;/i&gt;&#10;```&#10;   - Professional calendar icon for dates&#10;&#10;---&#10;&#10;### Section 2: Two-Column Layout&#10;&#10;**Structure:**&#10;```html&#10;&lt;div class=&quot;content-layout&quot;&gt;&#10;    &lt;section class=&quot;events-column&quot;&gt;&#10;        &lt;!-- LEFT COLUMN: Model.Events --&gt;&#10;    &lt;/section&gt;&#10;    &#10;    &lt;aside class=&quot;announcements-column&quot;&gt;&#10;        &lt;!-- RIGHT COLUMN: Model.Announcements --&gt;&#10;    &lt;/aside&gt;&#10;&lt;/div&gt;&#10;```&#10;&#10;#### CSS Grid Layout:&#10;```css&#10;.content-layout {&#10;    display: grid;&#10;    grid-template-columns: 2fr 1fr; /* 66% / 33% split */&#10;    gap: 2rem;&#10;}&#10;```&#10;&#10;---&#10;&#10;### Left Column: Events List&#10;&#10;**Lines 85-140** (approximately)&#10;&#10;```csharp&#10;&lt;section class=&quot;events-column&quot;&gt;&#10;    &lt;h2 class=&quot;section-title&quot;&gt;Upcoming Events&lt;/h2&gt;&#10;    &#10;    @if (Model.Events != null &amp;&amp; Model.Events.Any())&#10;    {&#10;        &lt;div class=&quot;events-list&quot;&gt;&#10;            @foreach (var evt in Model.Events)&#10;            {&#10;                &lt;div class=&quot;event-card&quot; data-category=&quot;@categoryClass&quot;&gt;&#10;                    &lt;!-- Event details --&gt;&#10;                    &lt;h3 class=&quot;event-title&quot;&gt;@evt.Title&lt;/h3&gt;&#10;                    &lt;i class=&quot;bi bi-calendar3 event-icon&quot;&gt;&lt;/i&gt;&#10;                    &lt;span&gt;@evt.StartDate.ToString(&quot;dddd, MMMM dd, yyyy&quot;) • @evt.StartDate.ToString(&quot;h:mm tt&quot;)&lt;/span&gt;&#10;                    &lt;p class=&quot;event-description&quot;&gt;@evt.Description&lt;/p&gt;&#10;                &lt;/div&gt;&#10;            }&#10;        &lt;/div&gt;&#10;    }&#10;    else&#10;    {&#10;        &lt;div class=&quot;empty-state&quot;&gt;&#10;            &lt;p&gt;No upcoming events found.&lt;/p&gt;&#10;        &lt;/div&gt;&#10;    }&#10;&lt;/section&gt;&#10;```&#10;&#10;#### Key Features:&#10;&#10;1. **Null-safe iteration**:&#10;   - Checks if `Model.Events` exists and has items&#10;   - Shows &quot;No events&quot; message if empty&#10;&#10;2. **Date formatting**:&#10;```csharp&#10;@evt.StartDate.ToString(&quot;dddd, MMMM dd, yyyy&quot;) // Saturday, October 19, 2025&#10;@evt.StartDate.ToString(&quot;h:mm tt&quot;)              // 6:00 PM&#10;```&#10;   - Readable date format&#10;   - Separate time display&#10;   - Uses bullet separator (•)&#10;&#10;3. **Dynamic category badge**:&#10;```html&#10;&lt;span class=&quot;event-category-badge badge-@categoryColor&quot;&gt;@evt.Category&lt;/span&gt;&#10;```&#10;   - Color-coded based on category&#10;   - Visual categorization&#10;&#10;4. **Bootstrap Icons**:&#10;```html&#10;&lt;i class=&quot;bi bi-calendar3 event-icon&quot;&gt;&lt;/i&gt;&#10;```&#10;   - Calendar icon for each event&#10;&#10;---&#10;&#10;### Right Column: Announcements Sidebar&#10;&#10;**Lines 145-175** (approximately)&#10;&#10;```csharp&#10;&lt;aside class=&quot;announcements-column&quot;&gt;&#10;    &lt;h2 class=&quot;section-title&quot;&gt;Municipal Announcements&lt;/h2&gt;&#10;    &#10;    @if (Model.Announcements != null &amp;&amp; Model.Announcements.Any())&#10;    {&#10;        &lt;div class=&quot;announcements-list&quot;&gt;&#10;            @foreach (var announcement in Model.Announcements)&#10;            {&#10;                &lt;div class=&quot;announcement-card&quot;&gt;&#10;                    &lt;div class=&quot;announcement-header&quot;&gt;&#10;                        &lt;i class=&quot;bi bi-megaphone announcement-icon&quot;&gt;&lt;/i&gt;&#10;                        &lt;h3 class=&quot;announcement-title&quot;&gt;@announcement.Title&lt;/h3&gt;&#10;                    &lt;/div&gt;&#10;                    &lt;p class=&quot;announcement-date&quot;&gt;@announcement.DatePosted.ToString(&quot;MMMM dd, yyyy&quot;)&lt;/p&gt;&#10;                    &lt;p class=&quot;announcement-content&quot;&gt;@announcement.Content&lt;/p&gt;&#10;                &lt;/div&gt;&#10;            }&#10;        &lt;/div&gt;&#10;    }&#10;    else&#10;    {&#10;        &lt;div class=&quot;empty-state&quot;&gt;&#10;            &lt;p&gt;No announcements at this time.&lt;/p&gt;&#10;        &lt;/div&gt;&#10;    }&#10;&lt;/aside&gt;&#10;```&#10;&#10;#### Key Features:&#10;&#10;1. **Semantic HTML**: Uses `&lt;aside&gt;` for sidebar content&#10;&#10;2. **Bootstrap Icons**: Megaphone icon for announcements&#10;```html&#10;&lt;i class=&quot;bi bi-megaphone announcement-icon&quot;&gt;&lt;/i&gt;&#10;```&#10;&#10;3. **Date formatting**:&#10;```csharp&#10;@announcement.DatePosted.ToString(&quot;MMMM dd, yyyy&quot;) // October 15, 2025&#10;```&#10;&#10;4. **Compact cards**: Smaller cards that fit the sidebar&#10;&#10;---&#10;&#10;### How Data Flows to the View:&#10;&#10;**Controller → ViewModel → View**&#10;&#10;**In Controller (LocalEventsController.cs):**&#10;```csharp&#10;var viewModel = new LocalEventsViewModel&#10;{&#10;    Events = events,                                           // Search results or all events&#10;    Announcements = await _localEventsService.GetAllAnnouncementsAsync(),&#10;    Categories = await _localEventsService.GetCategoriesAsync(),&#10;    RecommendedEvents = await _localEventsService.GetRecommendedEventsAsync()&#10;};&#10;&#10;return View(viewModel);&#10;```&#10;&#10;**In View (Index.cshtml):**&#10;- Receives the complete ViewModel&#10;- Accesses properties directly: `@Model.Events`, `@Model.Announcements`, `@Model.RecommendedEvents`&#10;- Razor syntax iterates and binds data&#10;&#10;---&#10;&#10;### Responsive Design:&#10;&#10;**Desktop (&gt; 768px):**&#10;- Two columns side-by-side&#10;- Recommendations in 3-column grid&#10;&#10;**Tablet/Mobile:**&#10;```css&#10;@media (max-width: 768px) {&#10;    .content-layout {&#10;        grid-template-columns: 1fr; /* Single column */&#10;    }&#10;    .recommendations-grid {&#10;        grid-template-columns: 1fr; /* Stack recommendations */&#10;    }&#10;}&#10;```&#10;&#10;---&#10;&#10;##  Prompt 4 — Data Structures&#10;&#10;### Complete Data Structures Overview in LocalEventsService.cs&#10;&#10;**Location:** Lines 13-18&#10;&#10;---&#10;&#10;### 1. SortedDictionary&lt;DateTime, List&lt;Event&gt;&gt;&#10;&#10;**Declaration:**&#10;```csharp&#10;private SortedDictionary&lt;DateTime, List&lt;Event&gt;&gt; _eventsByDate = new();&#10;```&#10;&#10;**Purpose:**&#10;- Stores events **grouped by date** in chronological order&#10;- Automatically maintains sort order&#10;&#10;**How It's Used:**&#10;```csharp&#10;if (!_eventsByDate.ContainsKey(ev.StartDate.Date))&#10;    _eventsByDate[ev.StartDate.Date] = new List&lt;Event&gt;();&#10;_eventsByDate[ev.StartDate.Date].Add(ev);&#10;```&#10;&#10;**Performance:**&#10;- **Insertion**: O(log n) - uses Red-Black tree internally&#10;- **Lookup**: O(log n)&#10;- **Enumeration**: O(n) - already sorted&#10;&#10;**Real-World Benefit:**&#10;- Quickly find all events on a specific date&#10;- Iterate events in chronological order without sorting&#10;- Example: &quot;Show me all events on October 20, 2025&quot;&#10;&#10;**Data Structure Type:** Tree-based (Red-Black Tree)&#10;&#10;---&#10;&#10;### 2. Dictionary&lt;string, List&lt;Event&gt;&gt;&#10;&#10;**Declaration:**&#10;```csharp&#10;private Dictionary&lt;string, List&lt;Event&gt;&gt; _eventsByCategory = new();&#10;```&#10;&#10;**Purpose:**&#10;- Groups events by category for instant category-based lookups&#10;- Used heavily in recommendations&#10;&#10;**How It's Used:**&#10;```csharp&#10;if (!_eventsByCategory.ContainsKey(ev.Category))&#10;    _eventsByCategory[ev.Category] = new List&lt;Event&gt;();&#10;_eventsByCategory[ev.Category].Add(ev);&#10;&#10;// Later in recommendations:&#10;recommended.AddRange(_eventsByCategory[topCategory]&#10;    .Where(e =&gt; e.StartDate &gt;= DateTime.Now)&#10;    .OrderBy(e =&gt; e.StartDate)&#10;    .Take(5));&#10;```&#10;&#10;**Performance:**&#10;- **Insertion**: O(1) average&#10;- **Lookup**: O(1) average&#10;- **Memory**: Efficient hash table&#10;&#10;**Real-World Benefit:**&#10;- Instant category filtering: &quot;Show me all Parks &amp; Recreation events&quot;&#10;- Powers the category-based recommendation strategy&#10;- No database query needed for category lookups&#10;&#10;**Data Structure Type:** Hash Table&#10;&#10;**Example Data:**&#10;```&#10;{&#10;  &quot;Community Events&quot;: [Event1, Event2, Event5],&#10;  &quot;Parks &amp; Recreation&quot;: [Event3, Event7],&#10;  &quot;Cultural Events&quot;: [Event4, Event6]&#10;}&#10;```&#10;&#10;---&#10;&#10;### 3. HashSet&lt;string&gt; (Categories)&#10;&#10;**Declaration:**&#10;```csharp&#10;private HashSet&lt;string&gt; _categories = new();&#10;```&#10;&#10;**Purpose:**&#10;- Stores unique category names&#10;- Automatically prevents duplicates&#10;- Powers the category dropdown filter&#10;&#10;**How It's Used:**&#10;```csharp&#10;_categories.Add(ev.Category); // Automatically handles duplicates&#10;&#10;// In controller:&#10;var categories = await _localEventsService.GetCategoriesAsync();&#10;```&#10;&#10;**Performance:**&#10;- **Add**: O(1) average&#10;- **Contains**: O(1) average&#10;- **Uniqueness**: Guaranteed&#10;&#10;**Real-World Benefit:**&#10;- Populate category dropdown with unique values&#10;- No duplicate &quot;Community Events&quot; entries&#10;- Fast membership testing&#10;&#10;**Data Structure Type:** Hash Set&#10;&#10;**Example Data:**&#10;```&#10;{&#10;  &quot;Community Events&quot;,&#10;  &quot;Parks &amp; Recreation&quot;,&#10;  &quot;Cultural Events&quot;,&#10;  &quot;Government Meetings&quot;,&#10;  &quot;Public Safety&quot;&#10;}&#10;```&#10;&#10;---&#10;&#10;### 4. HashSet&lt;DateTime&gt; (Unique Event Dates)&#10;&#10;**Declaration:**&#10;```csharp&#10;private HashSet&lt;DateTime&gt; _uniqueEventDates = new();&#10;```&#10;&#10;**Purpose:**&#10;- Stores all unique dates that have events&#10;- Could power a &quot;dates with events&quot; calendar picker&#10;&#10;**How It's Used:**&#10;```csharp&#10;_uniqueEventDates.Add(ev.StartDate.Date);&#10;&#10;public async Task&lt;IEnumerable&lt;DateTime&gt;&gt; GetUniqueEventDatesAsync()&#10;{&#10;    await LoadEventsIntoStructuresAsync();&#10;    return _uniqueEventDates;&#10;}&#10;```&#10;&#10;**Performance:**&#10;- **Add**: O(1) average&#10;- **Contains**: O(1) average&#10;- **Uniqueness**: Automatic&#10;&#10;**Real-World Benefit:**&#10;- Highlight dates in calendar UI that have events&#10;- Quick check: &quot;Are there events on October 25?&quot;&#10;- Avoid showing empty date results&#10;&#10;**Data Structure Type:** Hash Set&#10;&#10;---&#10;&#10;### 5. PriorityQueue&lt;Event, DateTime&gt;&#10;&#10;**Declaration:**&#10;```csharp&#10;private PriorityQueue&lt;Event, DateTime&gt; _upcomingEventsQueue = new();&#10;```&#10;&#10;**Purpose:**&#10;- Stores upcoming events sorted by start date&#10;- Always gives next upcoming event first&#10;- Only contains **future** events&#10;&#10;**How It's Used:**&#10;```csharp&#10;// During loading:&#10;if (ev.StartDate &gt;= DateTime.Now)&#10;{&#10;    _upcomingEventsQueue.Enqueue(ev, ev.StartDate);&#10;}&#10;&#10;// To get upcoming events:&#10;while (tempQueue.Count &gt; 0)&#10;{&#10;    result.Add(tempQueue.Dequeue()); // Gets earliest event&#10;}&#10;```&#10;&#10;**Performance:**&#10;- **Enqueue**: O(log n) - uses binary heap&#10;- **Dequeue**: O(log n) - removes minimum&#10;- **Peek**: O(1) - view next event&#10;&#10;**Real-World Benefit:**&#10;- Efficiently get &quot;next N upcoming events&quot;&#10;- Used in recommendation fallback&#10;- Always maintains priority order (earliest first)&#10;&#10;**Data Structure Type:** Min-Heap (Binary Heap)&#10;&#10;**Example Flow:**&#10;```&#10;Enqueue(Event1, Oct 20)&#10;Enqueue(Event2, Oct 18)  // Goes to front (earlier date)&#10;Enqueue(Event3, Oct 25)&#10;&#10;Dequeue() → Event2 (Oct 18)&#10;Dequeue() → Event1 (Oct 20)&#10;Dequeue() → Event3 (Oct 25)&#10;```&#10;&#10;---&#10;&#10;### 6. Stack&lt;Event&gt; (Recently Viewed)&#10;&#10;**Declaration:**&#10;```csharp&#10;private Stack&lt;Event&gt; _recentlyViewedEvents = new();&#10;```&#10;&#10;**Purpose:**&#10;- Tracks recently viewed events&#10;- LIFO (Last In, First Out) - most recent at top&#10;- Could power &quot;Continue browsing&quot; feature&#10;&#10;**How It's Used:**&#10;```csharp&#10;public void RecordEventViewed(Event ev)&#10;{&#10;    _recentlyViewedEvents.Push(ev);&#10;    &#10;    // Limit stack size to 20&#10;    if (_recentlyViewedEvents.Count &gt; 20)&#10;    {&#10;        var tempStack = new Stack&lt;Event&gt;(_recentlyViewedEvents.Reverse().Skip(1));&#10;        _recentlyViewedEvents = tempStack;&#10;    }&#10;}&#10;&#10;public IEnumerable&lt;Event&gt; GetRecentlyViewedEvents(int count = 5)&#10;{&#10;    return _recentlyViewedEvents.Take(count);&#10;}&#10;```&#10;&#10;**Performance:**&#10;- **Push**: O(1)&#10;- **Pop**: O(1)&#10;- **Peek**: O(1)&#10;&#10;**Real-World Benefit:**&#10;- Show &quot;Recently Viewed&quot; section&#10;- Quick access to events user looked at&#10;- Natural browsing history&#10;&#10;**Data Structure Type:** Stack (LIFO)&#10;&#10;**Example Flow:**&#10;```&#10;Push(Event A)&#10;Push(Event B)&#10;Push(Event C)&#10;&#10;GetRecentlyViewedEvents(2) → [Event C, Event B]&#10;```&#10;&#10;---&#10;&#10;### 7. List&lt;SearchHistoryItem&gt; (Search History)&#10;&#10;**Location:** `SearchHistoryService.cs`&#10;&#10;**Declaration:**&#10;```csharp&#10;public List&lt;SearchHistoryItem&gt; GetSearchHistory()&#10;```&#10;&#10;**Purpose:**&#10;- Stores user's last 10 searches&#10;- Tracks search text, category, and date&#10;- Session-based storage&#10;&#10;**How It's Used:**&#10;```csharp&#10;public void AddSearch(string? searchText, string? category, DateTime? date)&#10;{&#10;    var history = GetSearchHistory();&#10;    &#10;    history.Add(new SearchHistoryItem&#10;    {&#10;        SearchText = searchText,&#10;        Category = category,&#10;        Date = date&#10;    });&#10;&#10;    // Keep only last 10&#10;    if (history.Count &gt; MaxSearchHistory)&#10;    {&#10;        history.RemoveRange(0, history.Count - MaxSearchHistory);&#10;    }&#10;}&#10;```&#10;&#10;**Performance:**&#10;- **Add**: O(1) amortized&#10;- **RemoveRange**: O(n)&#10;- **Iteration**: O(n)&#10;&#10;**Real-World Benefit:**&#10;- Powers recommendation engine&#10;- Analyzes user search patterns&#10;- Privacy-friendly (session-only)&#10;&#10;**Data Structure Type:** Dynamic Array (List)&#10;&#10;---&#10;&#10;### Summary Table: Performance Comparison&#10;&#10;| Data Structure | Insertion | Lookup | Use Case | Big-O |&#10;|---------------|-----------|---------|----------|-------|&#10;| **SortedDictionary** | O(log n) | O(log n) | Events by date, sorted | Tree-based |&#10;| **Dictionary** | O(1) | O(1) | Events by category | Hash table |&#10;| **HashSet (strings)** | O(1) | O(1) | Unique categories | Hash set |&#10;| **HashSet (DateTime)** | O(1) | O(1) | Unique event dates | Hash set |&#10;| **PriorityQueue** | O(log n) | O(log n) | Upcoming events | Min-heap |&#10;| **Stack** | O(1) | O(1) | Recently viewed | LIFO |&#10;| **List** | O(1) | O(n) | Search history | Dynamic array |&#10;&#10;---&#10;&#10;### Why These Structures Matter:&#10;&#10;1. **Performance**: O(1) and O(log n) operations vs O(n) database queries&#10;2. **Efficiency**: Data loaded once, queried many times&#10;3. **Scalability**: Handles thousands of events efficiently&#10;4. **Flexibility**: Each structure optimized for its specific use case&#10;5. **Academic Merit**: Demonstrates understanding of data structure trade-offs&#10;&#10;---&#10;&#10;### Memory vs Database Trade-off:&#10;&#10;**Pros of In-Memory Structures:**&#10;✅ Lightning-fast lookups  &#10;✅ No network latency  &#10;✅ Reduced database load  &#10;✅ Complex filtering without SQL  &#10;&#10;**Cons:**&#10;❌ Memory usage (acceptable for event data)  &#10;❌ Must reload on updates (handled in code)  &#10;❌ Not persistent (refreshed from DB)  &#10;&#10;**Verdict:** Perfect for read-heavy operations like event browsing and recommendations.&#10;&#10;---&#10;&#10;## Video Presentation Tips&#10;&#10;### For Prompt 1 (Search Logic):&#10;1. Show the code in your IDE&#10;2. Demonstrate a live search with keyword + category + date&#10;3. Show the SQL query in SQL Server Profiler (optional)&#10;4. Highlight the async/await pattern&#10;&#10;### For Prompt 2 (Recommendations):&#10;1. Start with a fresh session (no recommendations)&#10;2. Perform 3-4 searches in the same category&#10;3. Refresh to show personalized recommendations&#10;4. Explain the frequency analysis live&#10;&#10;### For Prompt 3 (View Binding):&#10;1. Show the ViewModel class&#10;2. Show the controller building the ViewModel&#10;3. Show the view consuming the data&#10;4. Inspect the rendered HTML in browser DevTools&#10;&#10;### For Prompt 4 (Data Structures):&#10;1. Use a whiteboard or diagram tool&#10;2. Show how data flows into each structure&#10;3. Compare O(1) lookup vs O(n) database query&#10;4. Demonstrate with actual timing if possible&#10;&#10;---&#10;&#10;## Key Talking Points for Your Video&#10;&#10;### Academic Rigor:&#10;- &quot;I chose a **SortedDictionary** over a regular Dictionary because I need both fast lookups AND sorted iteration&quot;&#10;- &quot;The **PriorityQueue** ensures upcoming events are always retrieved in chronological order with O(log n) efficiency&quot;&#10;- &quot;Using a **HashSet** for categories automatically handles uniqueness, preventing duplicate entries in the dropdown&quot;&#10;&#10;### Real-World Application:&#10;- &quot;This recommendation engine learns from user behavior, just like Netflix or Amazon&quot;&#10;- &quot;Async/await prevents the UI from freezing during database queries&quot;&#10;- &quot;Session-based tracking respects user privacy while still providing personalization&quot;&#10;&#10;### Performance Benefits:&#10;- &quot;Loading events into memory once and querying them multiple times is far more efficient than repeated database calls&quot;&#10;- &quot;Dictionary lookups are O(1) - constant time, regardless of dataset size&quot;&#10;- &quot;The combination of strategies in recommendations ensures users always see relevant content&quot;&#10;&#10;---&#10;&#10;**Good luck with your video! **&#10;&#10;This document should give you everything you need to confidently explain your code's functionality, design decisions, and technical merit.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>